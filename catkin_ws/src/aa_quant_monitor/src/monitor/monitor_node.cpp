/**
 * @author: smitsch
 */

#include <csetjmp>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include <stdbool.h>

#include "ros/ros.h"
#include "ackermann_msgs/AckermannDriveStamped.h"
#include "nav_msgs/Odometry.h"
#include "geometry_msgs/Point.h"
#include "geometry_msgs/PointStamped.h"
#include "tf/transform_datatypes.h"
#include "diagnostic_msgs/DiagnosticArray.h"
#include "diagnostic_msgs/DiagnosticStatus.h"
#include "diagnostic_msgs/KeyValue.h"
#include "std_msgs/builtin_double.h"
//#include "std_msgs/Float64.h"

#include "aa_monitor/utils/utils.h"
#include "aa_monitor/utils/consts.h"

// ROS message types
typedef ackermann_msgs::AckermannDriveStamped action_t;
typedef nav_msgs::Odometry state_t;
typedef geometry_msgs::Point point_t;
typedef diagnostic_msgs::DiagnosticStatus diag_status_t;
typedef diagnostic_msgs::DiagnosticArray diag_array_t;
typedef diagnostic_msgs::KeyValue kv_t;
typedef geometry_msgs::PointStamped monitor_t;
//typedef std_msgs::Float64 aa_double_t;

// Queue size for ROS subscribers
const size_t QUEUE_SIZE = 1;

// Publishers with safe actions and monitor verdicts
static ros::Publisher safe_action_pub;
static ros::Publisher ctrl_monitor_verdict_pub;
static ros::Publisher plant_monitor_verdict_pub;
static ros::Publisher monitor_diagnostic_pub;

// Save subscribed messages for processing later
static double current_state_timestamp = -1;
static double last_state_timestamp = -1;
static std::vector<double> current_state;
static std::vector<double> current_waypoint;
static std::vector<double> proposed_action;

void printConsts(int A, int B, int T, int eps) {
    printf("Consts  A=%d,B=%d,T=%d,eps=%d\n", A, B, T, eps);
}

void printSensors(int t, int v, int xg, int yg) {
    printf("Sensors t=%d,v=%d,xg=%d,yg=%d\n",t,v,xg,yg);
}

void printCtrl(int a, int k, int t, int vh, int vl, int xg, int yg) {
    printf("Ctrl    a=%d,k=%d,t=%d,vh=%d,vl=%d,xg=%d,yg=%d\n",a,k,t,vh,vl,xg,yg);
}

void fillKV(const char* key, double val, diag_status_t &status) {
    char buf[128];
    sprintf(buf, "%f", val);
    kv_t kv;
    kv.key = key;
    kv.value = buf;
    status.values.push_back(kv);
}

/**************************
 * Plant-Monitor.c
 * Generated by KeYmaera X
 **************************/

typedef struct plantparameters {
  long double A;
  long double B;
  long double T;
  long double a;
  long double eps;
  long double k;
  long double vh;
  long double vl;
} plantparameters;

typedef struct plantstate {
  long double t;
  long double t_0;
  long double v;
  long double v_0;
  long double xg;
  long double xg_0;
  long double yg;
  long double yg_0;
} plantstate;

typedef struct input {} input;

typedef struct verdict { int id; long double val; } verdict;

/* Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe) */
verdict plantBoundaryDist(plantstate pre, plantstate curr, const plantparameters* const params) {
  if (pre.v >= 0.0L) {
if (pre.t <= params->T) {
if (((pre.t >= 0.0L) && (((((params->k)*((params->eps)*(params->eps)))-((200.0L)*(params->eps)))*(100.0L) < ((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))-((((2.0L)*(pre.xg))*(100.0L))*(10.0L))) && (((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))-((((2.0L)*(pre.xg))*(100.0L))*(10.0L)) < (((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))) || ((((10.0L)*(pre.v))+((params->a)*((params->T)-(pre.t))) >= 0.0L) && ((((params->a >= 0.0L) && (((10.0L)*(pre.v))+((params->a)*((params->T)-(pre.t))) <= (10.0L)*(params->vh))) || (((params->a <= 0.0L) && (pre.v <= params->vh)) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)-(pre.t)))*(10.0L))+((params->a)*(((params->T)-(pre.t))*((params->T)-(pre.t))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))*(((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t)))))-(((10.0L)*(params->vh))*((10.0L)*(params->vh))))) <= ((((2.0L)*(params->B))*((pre.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)-(pre.t)))*(10.0L))+((params->a)*(((params->T)-(pre.t))*((params->T)-(pre.t))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))*(((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t)))))-(((10.0L)*(params->vh))*((10.0L)*(params->vh))))) <= ((((2.0L)*(params->B))*((fabsl(pre.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L))))) && (((params->a >= 0.0L) && (pre.v >= params->vl)) || (((params->a <= 0.0L) && (((10.0L)*(pre.v))+((params->a)*((params->T)-(pre.t))) >= (10.0L)*(params->vl))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)-(pre.t)))*(10.0L))+((params->a)*(((params->T)-(pre.t))*((params->T)-(pre.t))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))-((((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))*(((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))))) <= ((((2.0L)*(params->A))*((pre.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)-(pre.t)))*(10.0L))+((params->a)*(((params->T)-(pre.t))*((params->T)-(pre.t))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))-((((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))*(((pre.v)*(10.0L))+((params->a)*((params->T)-(pre.t))))))) <= ((((2.0L)*(params->A))*((fabsl(pre.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))))))) {
if (curr.v >= 0.0L) {
if (curr.t <= params->T) {
if (((curr.t >= 0.0L) && (((((params->k)*((params->eps)*(params->eps)))-((200.0L)*(params->eps)))*(100.0L) < ((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))) && (((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)) < (((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))) || ((((10.0L)*(curr.v))+((params->a)*((params->T)-(curr.t))) >= 0.0L) && ((((params->a >= 0.0L) && (((10.0L)*(curr.v))+((params->a)*((params->T)-(curr.t))) <= (10.0L)*(params->vh))) || (((params->a <= 0.0L) && (curr.v <= params->vh)) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)-(curr.t)))*(10.0L))+((params->a)*(((params->T)-(curr.t))*((params->T)-(curr.t))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))*(((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t)))))-(((10.0L)*(params->vh))*((10.0L)*(params->vh))))) <= ((((2.0L)*(params->B))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)-(curr.t)))*(10.0L))+((params->a)*(((params->T)-(curr.t))*((params->T)-(curr.t))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))*(((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t)))))-(((10.0L)*(params->vh))*((10.0L)*(params->vh))))) <= ((((2.0L)*(params->B))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L))))) && (((params->a >= 0.0L) && (curr.v >= params->vl)) || (((params->a <= 0.0L) && (((10.0L)*(curr.v))+((params->a)*((params->T)-(curr.t))) >= (10.0L)*(params->vl))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)-(curr.t)))*(10.0L))+((params->a)*(((params->T)-(curr.t))*((params->T)-(curr.t))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))-((((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))*(((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))))) <= ((((2.0L)*(params->A))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)-(curr.t)))*(10.0L))+((params->a)*(((params->T)-(curr.t))*((params->T)-(curr.t))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))-((((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))*(((curr.v)*(10.0L))+((params->a)*((params->T)-(curr.t))))))) <= ((((2.0L)*(params->A))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))))))) {
if (curr.t_0 == pre.t) {
if (curr.v_0 == pre.v) {
if (curr.xg_0 == pre.xg) {
if (curr.yg_0 == pre.yg) {
verdict result = { .id=1, .val=((((((0.0L)+(-((0.0L)-(pre.v))))+(-((pre.t)-(params->T))))+(-(fminl(fmaxl((0.0L)-(pre.t), fmaxl(((((params->k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))+(-((((2.0L)*(pre.xg))*(100.0L))*(10.0L)))), (((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))+(-((((2.0L)*(pre.xg))*(100.0L))*(10.0L))))-((((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))), fmaxl((0.0L)-(((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t))))), fmaxl(fminl(fmaxl((0.0L)-(params->a), (((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t)))))-((10.0L)*(params->vh))), fminl(fmaxl(params->a, (pre.v)-(params->vh)), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((pre.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((fabsl(pre.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))), fminl(fmaxl((0.0L)-(params->a), (params->vl)-(pre.v)), fminl(fmaxl(params->a, ((10.0L)*(params->vl))-(((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t)))))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))))))-(((((2.0L)*(params->A))*((pre.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))))))-(((((2.0L)*(params->A))*((fabsl(pre.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))))))+(-((0.0L)-(curr.v))))+(-((curr.t)-(params->T))))+(-(fminl(fmaxl((0.0L)-(curr.t), fmaxl(((((params->k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)))), (((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))), fmaxl((0.0L)-(((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t))))), fmaxl(fminl(fmaxl((0.0L)-(params->a), (((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t)))))-((10.0L)*(params->vh))), fminl(fmaxl(params->a, (curr.v)-(params->vh)), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))), fminl(fmaxl((0.0L)-(params->a), (params->vl)-(curr.v)), fminl(fmaxl(params->a, ((10.0L)*(params->vl))-(((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t)))))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))))) }; return result;
} else {
verdict result = { .id=-1, .val=-1.0L }; return result;
}
} else {
verdict result = { .id=-2, .val=-1.0L }; return result;
}
} else {
verdict result = { .id=-3, .val=-1.0L }; return result;
}
} else {
verdict result = { .id=-4, .val=-1.0L }; return result;
}
} else {
verdict result = { .id=-5, .val=((-1.0L))+(-(fminl(fmaxl((0.0L)-(curr.t), fmaxl(((((params->k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)))), (((params->k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))), fmaxl((0.0L)-(((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t))))), fmaxl(fminl(fmaxl((0.0L)-(params->a), (((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t)))))-((10.0L)*(params->vh))), fminl(fmaxl(params->a, (curr.v)-(params->vh)), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+(((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))), fminl(fmaxl((0.0L)-(params->a), (params->vl)-(curr.v)), fminl(fmaxl(params->a, ((10.0L)*(params->vl))-(((10.0L)*(curr.v))+((params->a)*((params->T)+(-(curr.t)))))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(curr.v))*((params->T)+(-(curr.t))))*(10.0L))+((params->a)*(((params->T)+(-(curr.t)))*((params->T)+(-(curr.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t)))))*(((curr.v)*(10.0L))+((params->a)*((params->T)+(-(curr.t))))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))))) }; return result;
}
} else {
verdict result = { .id=-6, .val=((-1.0L))+(-((curr.t)-(params->T))) }; return result;
}
} else {
verdict result = { .id=-7, .val=((-1.0L))+(-((0.0L)-(curr.v))) }; return result;
}
} else {
verdict result = { .id=-8, .val=((-1.0L))+(-(fminl(fmaxl((0.0L)-(pre.t), fmaxl(((((params->k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))+(-((((2.0L)*(pre.xg))*(100.0L))*(10.0L)))), (((params->k)*(((pre.xg)*(pre.xg))+((pre.yg)*(pre.yg))))+(-((((2.0L)*(pre.xg))*(100.0L))*(10.0L))))-((((params->k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))), fmaxl((0.0L)-(((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t))))), fmaxl(fminl(fmaxl((0.0L)-(params->a), (((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t)))))-((10.0L)*(params->vh))), fminl(fmaxl(params->a, (pre.v)-(params->vh)), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((pre.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->B)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+(((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))+(-(((10.0L)*(params->vh))*((10.0L)*(params->vh)))))))-(((((2.0L)*(params->B))*((fabsl(pre.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))), fminl(fmaxl((0.0L)-(params->a), (params->vl)-(pre.v)), fminl(fmaxl(params->a, ((10.0L)*(params->vl))-(((10.0L)*(pre.v))+((params->a)*((params->T)+(-(pre.t)))))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))))))-(((((2.0L)*(params->A))*((pre.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(params->k)))*(100.0L)))+(((params->eps)*(params->eps))*((params->k)*(params->k))))*(((params->A)*(((((2.0L)*(pre.v))*((params->T)+(-(pre.t))))*(10.0L))+((params->a)*(((params->T)+(-(pre.t)))*((params->T)+(-(pre.t)))))))+((((params->vl)*(10.0L))*((params->vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t)))))*(((pre.v)*(10.0L))+((params->a)*((params->T)+(-(pre.t))))))))))-(((((2.0L)*(params->A))*((fabsl(pre.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))))) }; return result;
}
} else {
verdict result = { .id=-9, .val=((-1.0L))+(-((pre.t)-(params->T))) }; return result;
}
} else {
verdict result = { .id=-10, .val=((-1.0L))+(-((0.0L)-(pre.v))) }; return result;
};
}

/**************************
 * Ctrl-Monitor.c
 * Generated by KeYmaera X
 **************************/

typedef struct parameters {
  long double A;
  long double B;
  long double T;
  long double eps;
} parameters;

typedef struct state {
  long double a;
  long double k;
  long double t;
  long double v;
  long double vh;
  long double vl;
  long double xg;
  long double yg;
} state;

/* Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe) */
verdict boundaryDist(state pre, state curr, const parameters* const params) {
  if (((curr.xg >= 0.0L) && (curr.k >= 0.0L)) || ((curr.xg <= 0.0L) && (curr.k <= 0.0L))) {
if (curr.yg > 0.0L) {
if ((fabsl(curr.k))*(params->eps) <= 100.0L) {
if ((((curr.k)*((params->eps)*(params->eps)))-((200.0L)*(params->eps)))*(100.0L) < ((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))) {
if (((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)) < (((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)) {
if (0.0L <= curr.vl) {
if (curr.vl < curr.vh) {
if ((params->A)*(params->T) <= (10.0L)*((curr.vh)-(curr.vl))) {
if ((params->B)*(params->T) <= (10.0L)*((curr.vh)-(curr.vl))) {
if (-(params->B) <= curr.a) {
if (curr.a <= params->A) {
if (((10.0L)*(pre.v))+((curr.a)*(params->T)) >= 0.0L) {
if (((pre.v <= curr.vh) && (((10.0L)*(pre.v))+((curr.a)*(params->T)) <= (10.0L)*(curr.vh))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh))))) <= ((((2.0L)*(params->B))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh))))) <= ((((2.0L)*(params->B))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))) {
if (((curr.vl <= pre.v) && (((10.0L)*(pre.v))+((curr.a)*(params->T)) >= (10.0L)*(curr.vl))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T)))))) <= ((((2.0L)*(params->A))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T)))))) <= ((((2.0L)*(params->A))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))) {
if (curr.v == pre.v) {
if (curr.t == 0.0L) {
verdict result = { .id=1, .val=((((((((((((((0.0L)+(-(fminl(fmaxl((0.0L)-(curr.xg), (0.0L)-(curr.k)), fmaxl(curr.xg, curr.k)))))+(-((0.0L)-(curr.yg))))+(-(((fabsl(curr.k))*(params->eps))-(100.0L))))+(-(((((curr.k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)))))))+(-((((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))))+(-((0.0L)-(curr.vl))))+(-((curr.vl)-(curr.vh))))+(-(((params->A)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))))+(-(((params->B)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))))+(-((-(params->B))-(curr.a))))+(-((curr.a)-(params->A))))+(-((0.0L)-(((10.0L)*(pre.v))+((curr.a)*(params->T))))))+(-(fminl(fmaxl((pre.v)-(curr.vh), (((10.0L)*(pre.v))+((curr.a)*(params->T)))-((10.0L)*(curr.vh))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))+(-(fminl(fmaxl((curr.vl)-(pre.v), ((10.0L)*(curr.vl))-(((10.0L)*(pre.v))+((curr.a)*(params->T)))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))) }; return result;
} else {
verdict result = { .id=-1, .val=-fabs(curr.t) }; return result;
}
} else {
verdict result = { .id=-2, .val=-fabs(curr.v-pre.v) }; return result;
}
} else {
verdict result = { .id=-3, .val=((-1.0L))+(-(fminl(fmaxl((curr.vl)-(pre.v), ((10.0L)*(curr.vl))-(((10.0L)*(pre.v))+((curr.a)*(params->T)))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))) }; return result;
}
} else {
verdict result = { .id=-4, .val=((-1.0L))+(-(fminl(fmaxl((pre.v)-(curr.vh), (((10.0L)*(pre.v))+((curr.a)*(params->T)))-((10.0L)*(curr.vh))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))) }; return result;
}
} else {
verdict result = { .id=-5, .val=((-1.0L))+(-((0.0L)-(((10.0L)*(pre.v))+((curr.a)*(params->T))))) }; return result;
}
} else {
verdict result = { .id=-6, .val=((-1.0L))+(-((curr.a)-(params->A))) }; return result;
}
} else {
verdict result = { .id=-7, .val=((-1.0L))+(-((-(params->B))-(curr.a))) }; return result;
}
} else {
verdict result = { .id=-8, .val=((-1.0L))+(-(((params->B)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))) }; return result;
}
} else {
verdict result = { .id=-9, .val=((-1.0L))+(-(((params->A)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))) }; return result;
}
} else {
verdict result = { .id=-10, .val=((-1.0L))+(-((curr.vl)-(curr.vh))) }; return result;
}
} else {
verdict result = { .id=-11, .val=((-1.0L))+(-((0.0L)-(curr.vl))) }; return result;
}
} else {
verdict result = { .id=-12, .val=((-1.0L))+(-((((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))) }; return result;
}
} else {
verdict result = { .id=-13, .val=((-1.0L))+(-(((((curr.k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)))))) }; return result;
}
} else {
verdict result = { .id=-14, .val=((-1.0L))+(-(((fabsl(curr.k))*(params->eps))-(100.0L))) }; return result;
}
} else {
verdict result = { .id=-15, .val=((-1.0L))+(-((0.0L)-(curr.yg))) }; return result;
}
} else {
verdict result = { .id=-16, .val=((-1.0L))+(-(fminl(fmaxl((0.0L)-(curr.xg), (0.0L)-(curr.k)), fmaxl(curr.xg, curr.k)))) }; return result;
};
}

/* Evaluates monitor condition in prior and current state */
bool monitorSatisfied(state pre, state curr, const parameters* const params) {
  return boundaryDist(pre,curr,params).val >= 0.0L;
}

/* Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor */
state monitoredCtrl(state curr, const parameters* const params, const input* const in,
                    state (*ctrl)(state,const parameters* const,const input* const), state (*fallback)(state,const parameters* const,const input* const)) {
  state post = (*ctrl)(curr,params,in);
  verdict ctrlMonitorVerdict = boundaryDist(curr,post,params);

  //printf("Ctrl Monitor verdict %d=%Lf\n", ctrlMonitorVerdict.id, ctrlMonitorVerdict.val);
  monitor_t verdict_msg;
  verdict_msg.header.stamp = current_state_timestamp > 0 ? ros::Time(current_state_timestamp) : ros::Time();
  verdict_msg.point.x = ctrlMonitorVerdict.id;
  verdict_msg.point.y = ctrlMonitorVerdict.val;
  //aa_double_t verdict_msg;
  //verdict_msg.data = ctrlMonitorVerdict.val;
  ctrl_monitor_verdict_pub.publish(verdict_msg);

  diag_status_t new_status;
  if (ctrlMonitorVerdict.val >= 0) {
      new_status.level = diag_status_t::OK;
      new_status.message = "Control monitor satisfied";
  } else {
      new_status.level = diag_status_t::WARN;
      new_status.message = "Control monitor violation";
  }
  new_status.hardware_id = "ModelPlex";
  new_status.name = "Quantitative safety margin";
  fillKV("a [dm/s^2]", post.a, new_status);
  fillKV("k [centi-(meters^-1)]", post.k, new_status);
  fillKV("t [ds]", post.t, new_status);
  fillKV("vh [dm/s]", post.vh, new_status);
  fillKV("vl [dm/s]", post.vl, new_status);
  fillKV("xg [dm]", post.xg, new_status);
  fillKV("yg [dm]", post.yg, new_status);
  fillKV("mon.id", ctrlMonitorVerdict.id, new_status);
  fillKV("mon.val", ctrlMonitorVerdict.val, new_status);
  diag_array_t new_diag;
  new_diag.status.push_back(new_status);
  monitor_diagnostic_pub.publish(new_diag);
  
  if (ctrlMonitorVerdict.val < 0) {
      //printf("Engaging fallback (todo!)...\n");
      //return (*fallback)(curr,params,in);
      return post;
  } else return post;
}

state extCtrl(state pre, const parameters* const params, const input* const in) {
    std::vector<double> converted_action;
    std::vector<double> ctrl_action = proposed_action;
    ctrl_action.push_back(pre.a);
    ctrl_action.push_back(pre.vh);  // vh
    ctrl_action.push_back(pre.vl);  // vl
    ctrl_action.push_back(pre.xg);
    ctrl_action.push_back(pre.yg);
    ctrl_action.push_back(pre.k);
    convertAction(ctrl_action, converted_action);

    state result = {
        .a = converted_action[0],
        .k = converted_action[1],
        .t = converted_action[2],
        .v = pre.v,
        .vh = converted_action[3],
        .vl = converted_action[4],
        .xg = converted_action[5],
        .yg = converted_action[6]
    };

    //printf("Control a=%Lf k=%Lf xg=%Lf yg=%Lf\n", result.a, result.k, result.xg, result.yg);
    
    diag_status_t new_status;
    new_status.level = diag_status_t::OK;
    new_status.message = "External control";
    new_status.hardware_id = "ModelPlex";
    new_status.name = "Quantitative safety margin";
    fillKV("a [dm/s^2]", result.a, new_status);
    fillKV("k [centi-(meters^-1)]", result.k, new_status);
    fillKV("t [ds]", result.t, new_status);
    fillKV("vh [dm/s]", result.vh, new_status);
    fillKV("vl [dm/s]", result.vl, new_status);
    fillKV("xg [dm]", result.xg, new_status);
    fillKV("yg [dm]", result.yg, new_status);
    diag_array_t new_diag;
    new_diag.status.push_back(new_status);
    monitor_diagnostic_pub.publish(new_diag);
    
    return result;
}

state fallback(state pre, const parameters* const params, const input* const in) {
    pre.a = -MAX_MOTOR_ACCEL;
    return pre;
}

void actuate(state curr) {
    diag_status_t new_status;    
    
    new_status.level = diag_status_t::OK;
    new_status.message = "Actuate";
    new_status.hardware_id = "ModelPlex";
    new_status.name = "Quantitative safety margin";
    fillKV("a [dm/s^2]", curr.a, new_status);
    fillKV("k [centi-(meters^-1)]", curr.k, new_status);
    fillKV("t [ds]", curr.t, new_status);
    fillKV("vh [dm/s]", curr.vh, new_status);
    fillKV("vl [dm/s]", curr.vl, new_status);
    fillKV("xg [dm]", curr.xg, new_status);
    fillKV("yg [dm]", curr.yg, new_status);
    diag_array_t new_diag;
    new_diag.status.push_back(new_status);
    monitor_diagnostic_pub.publish(new_diag);
    
    double vset = fmax(0.0, curr.v+curr.a*T_CYCLE_TIME/100.0); // converts [dm/s^2]*[ds] to [m/s]
    
    // sanity check steering angle vs. planned curvature
    // convert curvature into steering angle (bicycle model), see utils.cpp#convertAction
    double steer = 0.0;
    double steer2 = 0.0;
    if (curr.k != 0.0) {
        double wheelbase = 0.257;
        double d_com_rear = 0.1294;
        double r = 1.0/(curr.k/100.0);
        steer = atan(1.0/sqrt((r*r-d_com_rear*d_com_rear)/(wheelbase*wheelbase)));
        steer2 = atan(wheelbase*curr.k/100.0);
        steer = curr.k < 0 ? steer : -steer;
    }

    //printf("Actuate k=%f v=%f v1=%f s=%f s1=%f s2=%f\n", curr.k, proposed_action[0], vset, proposed_action[1], steer, steer2);
    
    // publish to commands/keyboard
    action_t new_action;
    new_action.drive.speed = proposed_action[0]; //vset;
    new_action.drive.steering_angle = proposed_action[1];
    safe_action_pub.publish(new_action);

    // make controlLoop wait for new measurements
    last_state_timestamp = current_state_timestamp;
}

void controlLoop() {
    parameters params = {
        .A = MAX_MOTOR_ACCEL,
        .B = MAX_MOTOR_ACCEL,
        .T = T_CYCLE_TIME,
        .eps = 0.5
    };
    
    input in;
    
    state pre;
    state curr = {
        .a = 0.0,
        .k = 0.0,
        .t = 0.0,
        .v = 0.0,
        .vh = 10.0,
        .vl = 0.0,
        .xg = 0.0,
        .yg = 0.0
    }; 

    plantstate plantpre;
    plantstate plantcurr = {
      .t = 0.0,
      .t_0 = 0.0,
      .v = 0.0,
      .v_0 = 0.0,
      .xg = 0.0,
      .xg_0 = 0.0,
      .yg = 0.0,
      .yg_0 = 0.0,
    };

    // initialize defaults
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    current_state.push_back(0.0);
    proposed_action.push_back(0.0);
    proposed_action.push_back(0.0);
    current_waypoint.push_back(0.0);
    current_waypoint.push_back(0.0);
    current_waypoint.push_back(0.0);

    printf("Defaults initialized, now starting control loop...\n");
    
    int i = 10000;
    while (--i > 0) {
        pre = curr;
        plantpre = plantcurr;
        
        std::vector<double> ctrl_state = current_state;
        ctrl_state.insert(ctrl_state.end(), current_waypoint.begin(), current_waypoint.end());
        std::vector<double> converted_state;
        convertState(ctrl_state, converted_state);

        long double time = current_state_timestamp-last_state_timestamp;
        
        
        curr = {
            .a = time > 0.0L ? (converted_state[4] - pre.v)/time : 0.0L, // approximate a [dm/s^2] from after the fact instead of directly from vset //pre.a,
            .k = converted_state[9],
            .t = time*10.0,
            .v = converted_state[4],
            .vh = pre.vh,
            .vl = pre.vl,
            .xg = converted_state[7],
            .yg = converted_state[8]
        };

        //printf("Acceleration comp v0=%Lf v=%Lf t=%Lf a=%Lf\n", pre.v, curr.v, time, curr.a);

        // plant monitor
        plantparameters plantParams = {
           .A = params.A,
           .B = params.B,
           .T = params.T,
           .a = curr.a,
           .eps = params.eps,
           .k = curr.k,
           .vh = curr.vh,
           .vl = curr.vl
        };

        plantcurr = {
          .t = curr.t,
          .t_0 = pre.t,
          .v = curr.v,
          .v_0 = pre.v,
          .xg = curr.xg,
          .xg_0 = pre.xg,
          .yg = curr.yg,
          .yg_0 = pre.yg,
        };
        
        //printf("Evaluating plant monitor p.t=%Lf p.t_0=%Lf p.v=%Lf p.v_0=%Lf p.xg=%Lf p.xg_0=%Lf p.yg=%Lf p.yg_0=%Lf c.t=%Lf c.t_0=%Lf c.v=%Lf c.v_0=%Lf c.xg=%Lf c.xg_0=%Lf c.yg=%Lf c.yg_0=%Lf A=%Lf B=%Lf T=%Lf a=%Lf eps=%Lf k=%Lf vh=%Lf vl=%Lf\n", plantpre.t, plantpre.t_0, plantpre.v, plantpre.v_0, plantpre.xg, plantpre.xg_0, plantpre.yg, plantpre.yg_0, plantcurr.t, plantcurr.t_0, plantcurr.v, plantcurr.v_0, plantcurr.xg, plantcurr.xg_0, plantcurr.yg, plantcurr.yg_0, plantParams.A, plantParams.B, plantParams.T, plantParams.a, plantParams.eps, plantParams.k, plantParams.vh, plantParams.vl);
        verdict plantVerdict = plantBoundaryDist(plantpre, plantcurr, &plantParams);
        //printf("Plant monitor id=%d val=%Lf\n", plantVerdict.id, plantVerdict.val);
        
        diag_status_t new_status;    
        new_status.level = plantVerdict.id > 0 ? diag_status_t::OK : diag_status_t::WARN;
        new_status.message = "Plant monitor";
        new_status.hardware_id = "ModelPlex";
        new_status.name = "Quantitative safety margin";
        fillKV("a [dm/s^2]", plantParams.a, new_status);
        fillKV("k [centi-(meters^-1)]", plantParams.k, new_status);
        fillKV("pre.t [ds]", plantpre.t, new_status);
        fillKV("curr.t [ds]", plantcurr.t, new_status);
        fillKV("pre.v [dm/s]", plantpre.v, new_status);
        fillKV("curr.v [dm/s]", plantcurr.v, new_status);
        fillKV("pre.xg [dm]", plantpre.xg, new_status);
        fillKV("curr.xg [dm]", plantcurr.xg, new_status);
        fillKV("pre.yg [dm]", plantpre.yg, new_status);
        fillKV("curr.yg [dm]", plantcurr.yg, new_status);
        fillKV("mon.id", plantVerdict.id, new_status);
        fillKV("mon.val", plantVerdict.val, new_status);
        diag_array_t new_diag;
        new_diag.status.push_back(new_status);
        monitor_diagnostic_pub.publish(new_diag);

        monitor_t verdict_msg;
        verdict_msg.header.stamp = current_state_timestamp > 0 ? ros::Time(current_state_timestamp) : ros::Time();
        verdict_msg.point.x = plantVerdict.id;
        verdict_msg.point.y = plantVerdict.val;
        plant_monitor_verdict_pub.publish(verdict_msg);
        

        //printf("Control...\n");        
        state ctrlAction = monitoredCtrl(curr, &params, &in, extCtrl, fallback);

        //printf("Actuate...\n");
        actuate(ctrlAction);

        ros::spinOnce();

        while (current_state_timestamp == last_state_timestamp) {
          // convert [ds]->[s] and wait 1/10th of T_CYCLE_TIME
          ros::Duration(T_CYCLE_TIME/100.0).sleep();
          ros::spinOnce();
        }
    }
}

/**************************/
/* ROS-specific functions */
/**************************/

void stateCallback(const state_t::ConstPtr& msg) {
    current_state.clear();
    ROS_INFO("Received state %f %f\n", msg->pose.pose.position.x, msg->pose.pose.position.y);
    current_state.push_back(msg->pose.pose.position.x);
    current_state.push_back(msg->pose.pose.position.y);
    current_state.push_back(msg->pose.pose.position.z);
    current_state.push_back(tf::getYaw(msg->pose.pose.orientation));
    current_state.push_back(msg->twist.twist.linear.x);
    current_state.push_back(msg->twist.twist.linear.y);
    current_state.push_back(msg->twist.twist.angular.z);
    current_state_timestamp = msg->header.stamp.toSec();
}

void actionCallback(const action_t::ConstPtr& msg) {
    proposed_action.clear();
    ROS_INFO("Received action %f %f\n", msg->drive.speed, msg->drive.steering_angle);
    proposed_action.push_back(msg->drive.speed);
    proposed_action.push_back(msg->drive.steering_angle);
}

void waypointCallback(const point_t::ConstPtr& msg) {
    current_waypoint.clear();
    ROS_INFO("Received waypoint %f %f %f\n", msg->x, msg->y, msg->z);
    current_waypoint.push_back(msg->x);  // xg
    current_waypoint.push_back(msg->y);  // yg
    current_waypoint.push_back(msg->z);  // k
}

int main (int argc, char **argv) {

    // Initialize ROS
    ros::init(argc, argv, "aa_quant_monitor");
    ros::NodeHandle nh;
    safe_action_pub = nh.advertise<action_t>("commands/keyboard",
            QUEUE_SIZE);
    monitor_diagnostic_pub = nh.advertise<diag_array_t>("diagnostics", QUEUE_SIZE);
    ctrl_monitor_verdict_pub = nh.advertise<monitor_t>("aa_quant_monitor/ctrlverdict", QUEUE_SIZE);
    plant_monitor_verdict_pub = nh.advertise<monitor_t>("aa_quant_monitor/plantverdict", QUEUE_SIZE);
    ros::Subscriber state_sub = nh.subscribe("ekf_localization/odom",
            QUEUE_SIZE, stateCallback);
    ros::Subscriber action_sub = nh.subscribe("aa_planner/commands",
            QUEUE_SIZE, actionCallback);
    ros::Subscriber waypoint_sub = nh.subscribe("aa_planner/waypoints",
            QUEUE_SIZE, waypointCallback);

    controlLoop();
}
